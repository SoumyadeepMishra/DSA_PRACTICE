# Minimum depth of a Binary Tree

code(BFS)

```cpp

class Solution {
public:
    int minDepth(TreeNode* root) {
        if(root == nullptr) return 0;
        queue<TreeNode*> que;
        que.push(root);
        int depth = 1;

        while(!que.empty()){
            int n = que.size();
            while(n--){
                TreeNode* temp = que.front();
                que.pop();
            // the node is a leaf ndoe
                if(temp->left == nullptr && temp->right == nullptr){
                    return depth;
                }
                if(temp->left) que.push(temp->left);
                if(temp->right) que.push(temp->right);
            }
            depth++;
        }

        return depth;
    }
};

```

code(DFS)

```cpp

class Solution {
public:

    int helper(TreeNode* root){
        if(root == nullptr) return 0;

        if(root->left == nullptr && root->right == nullptr) return 1;

        int l = root->left != nullptr ? helper(root->left) : INT_MAX;
        int r = root->right != nullptr ? helper(root->right) : INT_MAX;
        
        return 1 + min(l, r);
    }

    int minDepth(TreeNode* root) {
        if(root == nullptr) return 0;
        
        return helper(root);
    }
};

```