# Binary Tree Prunning (Subtree should have atleast one 1)

code (Brute Force) --> 0(n^2)

```cpp

class Solution {
public:

    bool isOnePresent(TreeNode* root){
        if(root == nullptr) return false;
        
        if(root->val == 1) return true;

        return isOnePresent(root->left) || isOnePresent(root->right);
    }

    TreeNode* pruneTree(TreeNode* root) {
        if(root == nullptr) return nullptr;

        if(!isOnePresent(root->left)) root->left = nullptr;
        if(!isOnePresent(root->right)) root->right = nullptr;

        root->left =  pruneTree(root->left);
        root->right =  pruneTree(root->right);

        if(root->left == nullptr && root->right == nullptr && root->val == 0) return nullptr;
        return root;
    }
};

```

code( Optimal Approach) --> 0(n)

```cpp

class Solution {
public:
    TreeNode* pruneTree(TreeNode* root) {
        // optimal approach 
        if(root == nullptr) return nullptr;

        // left aur right me jaao
        root->left = pruneTree(root->left);
        root->right = pruneTree(root->right);

        if(root->left == nullptr && root->right == nullptr && root->val == 0) return nullptr;
        return root;
    }
};

```
